{"meta":{"title":"Jlex の Blog","subtitle":"书山有路勤为径，学海无涯苦作舟","description":"一位不专心搞地质的CS Learner","author":"钟军","url":"https://jlexzhong.github.io/blog","root":"/blog/"},"pages":[{"title":"标签","date":"2021-08-23T15:01:42.000Z","updated":"2021-08-30T11:42:58.175Z","comments":true,"path":"tags/index.html","permalink":"https://jlexzhong.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-08-23T15:01:42.000Z","updated":"2021-09-02T09:37:24.101Z","comments":true,"path":"about/index.html","permalink":"https://jlexzhong.github.io/blog/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-23T15:00:09.000Z","updated":"2021-08-30T03:20:51.821Z","comments":true,"path":"categories/index.html","permalink":"https://jlexzhong.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2021-08-30T11:46:35.000Z","updated":"2021-08-30T11:46:55.370Z","comments":true,"path":"link/index.html","permalink":"https://jlexzhong.github.io/blog/link/index.html","excerpt":"","text":""}],"posts":[{"title":"解决tensorboard 1.13.1 无法打开生成的网址","slug":"solve-tensorboard-1.13.1-cannot-open-url","date":"2021-09-11T14:00:09.000Z","updated":"2021-09-14T02:21:58.442Z","comments":true,"path":"2021/09/11/solve-tensorboard-1.13.1-cannot-open-url/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/09/11/solve-tensorboard-1.13.1-cannot-open-url/","excerpt":"","text":"解决tensorboard 1.13.1 无法打开生成的网址使用命令： tensorboard --logdir=logs 得到如下网址： TensorBoard 1.15.0 at http://LAPTOP-10GIDQTB:6006/ (Press CTRL+C to quit) 出现了计算机的名字LAPTOP-10GIDQTB 在命令行中加上--host=127.0.0.1，即可完美解决 完整命令： tensorboard --logdir=colab_logs --host=127.0.0.1","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/categories/tensorflow/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://jlexzhong.github.io/blog/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/tags/tensorflow/"},{"name":"keras","slug":"keras","permalink":"https://jlexzhong.github.io/blog/tags/keras/"},{"name":"BUG","slug":"BUG","permalink":"https://jlexzhong.github.io/blog/tags/BUG/"}]},{"title":"python开发中遇到的原生问题","slug":"python_BUG","date":"2021-09-11T04:00:09.000Z","updated":"2021-09-14T02:25:18.704Z","comments":true,"path":"2021/09/11/python_BUG/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/09/11/python_BUG/","excerpt":"","text":"python开发中遇到的原生问题BUG： ```BUG:QObject::startTimer: Timers cannot be started from another thread - 原因：多线程问题。在子线程中对主线程的对象进行操作。 - 解决方案：子线程中发送信号，然后再主线程中接受信号并执行相应的操作。 **BUG：** - ``` QObject::setParent: Cannot set parent, new parent is in a different thread QBackingStore::endPaint() called with active painter; did you forget to destroy it or call QPainter::end() on it? 解决方法：子线程发送信号，数据为item，报错！！ 暂未解决 BUG： ImportError: cannot import name ‘Flask’ from partially initialized module ‘flask’ (most likely due to a circular import) (C:\\Users \\Administrator\\PycharmProjects\\test\\venv\\lib\\site-packages\\flask_init_.py) 原因：导入的包和运行.py脚本的名字相同，改名即可","categories":[{"name":"Python","slug":"Python","permalink":"https://jlexzhong.github.io/blog/categories/Python/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://jlexzhong.github.io/blog/tags/BUG/"},{"name":"Python","slug":"Python","permalink":"https://jlexzhong.github.io/blog/tags/Python/"}]},{"title":"mask r-cnn 遇到的坑","slug":"mask_rcnn-bug-note","date":"2021-09-09T04:00:09.000Z","updated":"2021-09-14T02:18:36.664Z","comments":true,"path":"2021/09/09/mask_rcnn-bug-note/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/09/09/mask_rcnn-bug-note/","excerpt":"","text":"mask r-cnn 遇到的坑 记录BUG：module ‘tensorflow.compat.v2.internal‘ has no attribute ‘register_clear_session_function’ 已解决更新tensorflow版本 tensorflow.python.keras.engine’ has no attribute ‘Layer’ 已解决改为： keras.layers.Layer https://www.e-learn.cn/topic/2433086 Tried to convert ‘shape’ to a tensor and failed. Error: None values not supported.https://github.com/matterport/Mask_RCNN/issues/1820 NO.1You can also try call tf.reshape(out_tensor, self.compute_output_shape(input_shape)) after each usage of Custom Layer.More info:https://stackoverflow.com/questions/51028861/tensorflow-compute-output-shape-not-working-for-custom-layertensorflow/tensorflow#33785 But in spite of this, the model summary differ in keras and tf.keras. NO.2To solve the problem, you can change this line:mrcnn_bbox = KL.Reshape((s[1], num_classes, 4), name=\"mrcnn_bbox\")(x)by :mrcnn_bbox = KL.Reshape((-1, num_classes, 4), name=\"mrcnn_bbox\")(x) It works for me and the output is fine. tf1.13.2解决编码问题：AttributeError: ‘str’ object has no attribute ‘decode’ 出现问题原因：str与bytes表示的是两种数据类型，str为字符串型，bytes为字节型。对str编码encode得到bytes，对bytes解码得到str，两者互为转换。而上面出现问题的原因是对str字符串使用了解码，显然是猪头不对马尾。 删除decode('utf-8') pip install h5py==2.10.0 invalid literal for int() with base 10: ‘pths’nameinfo = \"pths\" image_info.update({\"id\": int(name_info)}) 强制转换成int类型时，传入的字符串必须是有数字字符组成的，例如：x = int(\"111\") 加载权重时出现“AttributeError: ‘str‘ object has no attribute ‘decode‘ “https://blog.csdn.net/weixin_45371989/article/details/109789132?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.essearch_pc_relevant 解决办法貌似是由于h5py模块的版本问题，改用2.10版本 pip install h5py==2.10 -i https://pypi.doubanio.com/simple 发生异常: IndexError ：boolean index did not match indexed array along dimension 0; dimension is 0 but corresponding boolean dimension is 1 暂未解决，环境配置成一模一样也没用 后来发现没有更改分类的参数T_T Input image dtype is bool. Interpolation is not defined with bool data typehttps://stackoverflow.com/questions/62330374/input-image-dtype-is-bool-interpolation-is-not-defined-with-bool-data-type pip install -U scikit-image==0.16.2 Error when checking input: expected input_image_meta to have shape (15,) but got array with shape (16,)解决：因为我增加了一类，但是没有修改class_nums 解决办法是修改NUM_CLASSES参数，增加了多少类，就对应的修改对应数值 NUM_CLASSES = 1 + 1 https://blog.csdn.net/oMoDao1/article/details/83860101 AttributeError: module ‘yaml’ has no attribute ‘FullLoader’pip install --ignore-installed PyYAML [1].AttributeError: ‘module’ object has no attribute ‘FullLoader’. https://github.com/Yelp/elastalert/issues/2298 [2].安装yaml报错：ERROR: Cannot uninstall ‘PyYAML’. https://blog.csdn.net/weixin_41010198/article/details/103852838 keras 导入包报错 ImportError: cannot import name ‘moving_averages’pip3 install --upgrade --ignore-installed tensorflow-gpu==1.13.2 https://github.com/tensorflow/tensorflow/issues/8513 AttributeError: module ‘labelme.utils’ has no attribute ‘draw_label’将版本降为3.16.2 pip install labelme==3.16.2 IndexError: boolean index did not match indexed array along dimension 0; dimension is 0 but corresponding boolean dimension is 1https://blog.csdn.net/Alchemist_wjt/article/details/89954791?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=IndexError:%20boolean%20index%20did%20&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-89954791.pc_search_result_hbase_insert&amp;spm=1018.2226.3001.4187 新版本的labelme生成的label.png图为8位彩色图，不需要16位转8位转换！！！直接使用即可！注意观察自己的label.png的位深度！ BUG--------------------------------------------------------------------------- AssertionError Traceback (most recent call last) &lt;ipython-input-28-90029a2660a7&gt; in &lt;module&gt;() 13 (\"refined_anchors_clipped\", model.ancestor(pillar, \"ROI/refined_anchors_clipped:0\")), 14 (\"post_nms_anchor_ix\", nms_node), ---&gt; 15 (\"proposals\", model.keras_model.get_layer(\"ROI\").output), 16 ]) /content/drive/My Drive/mask rcnn_test/mrcnn/model.py in run_graph(self, images, outputs, image_metas) 2663 outputs = OrderedDict(outputs) 2664 for o in outputs.values(): -&gt; 2665 assert o is not None 2666 2667 # Build a Keras function to run parts of the computation graph AssertionError: 暂未找到解决方法，或许： 版本问题，使用的是1.13 1.15 是分割单类别，多类别是否会出现？","categories":[{"name":"Mask R-CNN","slug":"Mask-R-CNN","permalink":"https://jlexzhong.github.io/blog/categories/Mask-R-CNN/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://jlexzhong.github.io/blog/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/tags/tensorflow/"},{"name":"keras","slug":"keras","permalink":"https://jlexzhong.github.io/blog/tags/keras/"},{"name":"Mask R-CNN","slug":"Mask-R-CNN","permalink":"https://jlexzhong.github.io/blog/tags/Mask-R-CNN/"},{"name":"实例分割","slug":"实例分割","permalink":"https://jlexzhong.github.io/blog/tags/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"}]},{"title":"使用Mask-R-CNN训练自己的数据集","slug":"use-Mask-R-CNN-train-dataset-myself","date":"2021-09-09T04:00:09.000Z","updated":"2021-09-14T02:22:43.807Z","comments":true,"path":"2021/09/09/use-Mask-R-CNN-train-dataset-myself/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/09/09/use-Mask-R-CNN-train-dataset-myself/","excerpt":"","text":"使用Mask-R-CNN训练自己的数据集训练自己数据的步骤： 安装Labelmepip install labelme pip install pyqt5 pip install pillow==4.0.0 标注数据 使用labelme得到json标注文件 使用命令labelme_json_to_dataset 1.json得到json文件夹 也可以用批处理脚本得到所有json文件夹 得到4个文件夹标注信息 代码中需要改动的地方： NUM_CLASSES：表示类别的个数 self.add_class(“shapes”, 1, “category1”) 添加标签中定义的类别 指定好路径 dataset_root_path=\"mydata/\" img_floder = dataset_root_path + \"pic\" mask_floder = dataset_root_path + \"cv2_mask\" imglist = os.listdir(img_floder) count = len(imglist) DETECTION_MIN_CONFIDENCE 指定的稍微小一点可以得到更多结果 训练之后测试结果 先得到.h5的模型文件 参考demo.ipynb文件来写测试脚本 Using a generator with use_multiprocessing=True and multiple workers may duplicate your data. Pleahttps://github.com/keras-team/keras/pull/8662 https://github.com/matterport/Mask_RCNN/issues/514 https://github.com/matterport/Mask_RCNN/pull/740 https://blog.csdn.net/qq_35874169/article/details/116203228 https://www.gitmemory.com/issue/reigngt09/mask-rcnn/2/623180746 退出重新启动Google colab运行时即可解决问题。","categories":[{"name":"Mask R-CNN","slug":"Mask-R-CNN","permalink":"https://jlexzhong.github.io/blog/categories/Mask-R-CNN/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://jlexzhong.github.io/blog/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/tags/tensorflow/"},{"name":"keras","slug":"keras","permalink":"https://jlexzhong.github.io/blog/tags/keras/"},{"name":"Mask R-CNN","slug":"Mask-R-CNN","permalink":"https://jlexzhong.github.io/blog/tags/Mask-R-CNN/"},{"name":"实例分割","slug":"实例分割","permalink":"https://jlexzhong.github.io/blog/tags/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"}]},{"title":"tensorflow.js部署到web 笔记","slug":"tensorflow.js-deploy-web","date":"2021-09-02T04:00:09.000Z","updated":"2021-09-14T02:22:09.708Z","comments":true,"path":"2021/09/02/tensorflow.js-deploy-web/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/09/02/tensorflow.js-deploy-web/","excerpt":"","text":"tensorflow.js部署到web 笔记BUG： 无法加载源映射 Could not read source map for https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest: Unexpected 404 response from https://cdn.jsdelivr.net/npm/@tensorflow/tf.min.js.map: Failed to resolve the requested file. 解决：（https://www.nuomiphp.com/eplan/188052.html） 换成\"&lt;script src=\"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js\"&gt; &lt;/script&gt;\" 加载模型报错 lambda，inception_resnet_v2报错，inceptionV3并不报错 Uncaught (in promise) Error: Unknown layer: Lambda. This may be due to one of the following reasons: The layer is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code. The custom layer is defined in JavaScript, but is not registered properly with tf.serialization.registerClass(). at new t (errors.ts:48) at deserializeKerasObject (generic_utils.ts:202) at deserialize (serialization.ts:27) at i (container.ts:1329) at t.fromConfig (container.ts:1355) at deserializeKerasObject (generic_utils.ts:235) at deserialize (serialization.ts:27) at models.ts:270 at index.ts:79 at Object.next (index.ts:79) 参考： https://github.com/tensorspace-team/tensorspace/issues/121 https://stackoverflow.com/questions/66616597/tensorflow-js-error-in-loading-augmentation-layers-operation https://www.jianshu.com/p/dd2bebfa867d https://zhuanlan.zhihu.com/p/86355195 bug2在替换掉lambda后出现，基础库 Uncaught (in promise) TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator)) at Fv (runtime.js:747) at t.fromConfig (container.js:1232) at eO (generic_utils.js:278) at aM (serialization.js:31) at u (container.js:1206) at t.fromConfig (container.js:1234) at eO (generic_utils.js:278) at aM (serialization.js:31) at models.js:295 at c (runtime.js:63) tf.fromPixels Uncaught (in promise) TypeError: tf.fromPixels is not a function 已解决：https://stackoverflow.com/questions/55402551/why-am-i-getting-the-error-tf-frompixels-is-not-a-function tf.fromPixels was deprecated in version 1.0.0, use: tf.browser.fromPixels() getImageData 'getImageData' on 'CanvasRenderingContext2D': Value is not of type 'long'. 我是这么写的： const imgData = context.getImageData(0,0,canvas.width,canvas.height); 已解决：换成const imgData = context.getImageData(0,0,299,299); tensorflow.js没有tf.argmax，变成了tf.argMax 加载模型时路径的写法const my_model = await tf.loadLayersModel(\"model_js/model.json\") //正确 const my_model = await tf.loadLayersModel(\"http://127.0.0.1:5502/TensorFlow%20Deployment/Course%201%20-%20TensorFlow-JS/Week%204/Examples/model_js/model.json\") //正确,前面一大串是工作区文件夹名称 tensorflow.js的预测结果与tensorflow大相径庭图片：hym_003(-)_180.jpg tensorflow.js[[0.0038602, 0.0000056, 0.136271, 0.0231699, 4e-7, 5e-7, 1e-7, 0.0000079, 4e-7, 0.836684],] tensorflow-pythonarray([[6.1449555e-08, 7.2196451e-07, 9.9997318e-01, 2.7251541e-08, 4.4864832e-09, 2.8673458e-07, 1.8537765e-05, 2.0686712e-06, 9.0471025e-10, 5.0913218e-06]], dtype=float32) https://github.com/tensorflow/tfjs/issues/776 后续更新部署。","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/categories/tensorflow/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://jlexzhong.github.io/blog/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/tags/tensorflow/"},{"name":"tensorflow.js","slug":"tensorflow-js","permalink":"https://jlexzhong.github.io/blog/tags/tensorflow-js/"}]},{"title":"基于InceptionV3深度学习实现岩石图像智能识别与分类","slug":"by-InceptionV3-transfer-learning","date":"2021-09-01T10:00:09.000Z","updated":"2021-09-14T02:18:49.472Z","comments":true,"path":"2021/09/01/by-InceptionV3-transfer-learning/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/09/01/by-InceptionV3-transfer-learning/","excerpt":"","text":"基于InceptionV3深度学习实现岩石图像智能识别与分类总体流程 整理数据集（训练集、验证集），按照目录格式分类 读取数据集图像，归一化处理和数据增强 加载预训练模型InceptionV3，作为基础模型 在Inception卷积神经网络的瓶颈层后设计适用于本项目的网络结构，成为my_mode 冻结预训练模型的所有层，变为不可训练，便于正确获得瓶颈层输出的特征，自己添加的层需要训练。相当于把InceptionV3变为一个特征提取器 编译、训练、保存 预测：读取需识别的图像，转换数据格式，预测输出 数据预处理使用一个ImageDataGenerator图片生成器，定义图片处理以及数据增强相关 ImageDataGenerator，这个API提供数据处理相关功能，以及数据增强功能，使得数据多样化 ```datagen = ImageDataGenerator(rescale=1. / 255, # 归一化 zoom_range=0.2, rotation_range=40., channel_shift_range=25., width_shift_range=0.2, height_shift_range=0.2, horizontal_flip=True, fill_mode='nearest') # fill_mode：‘constant’，‘nearest’，‘reflect’或‘wrap’之一， # 当进行变换时超出边界的点将根据本参数给定的方法进行处理 + 参数（参考：http://www.51zixue.net/Keras/853.html） + **featurewise_cente**r：布尔值，使输入数据集去中心化（均值为0）, 按feature执行 + **samplewise_center**：布尔值，使输入数据的每个样本均值为0 + **featurewise_std_normalization**：布尔值，将输入除以数据集的标准差以完成标准化, 按feature执行 + **samplewise_std_normalization**：布尔值，将输入的每个样本除以其自身的标准差 + **zca_whitening**：布尔值，对输入数据施加ZCA白 + **zca_epsilon**: ZCA使用的eposilon，默认1e-6 + **rotation_range**：整数，数据提升时图片随机转动的角度 + **width_shift_range**：浮点数，图片宽度的某个比例，数据提升时图片水平偏移的幅度 + **height_shift_range**：浮点数，图片高度的某个比例，数据提升时图片竖直偏移的幅度 + **shear_range**：浮点数，剪切强度（逆时针方向的剪切变换角度） + **zoom_range**：浮点数或形如[lower,upper]的列表，随机缩放的幅度，若为浮点数，则相当于[lower,upper] = [1 - zoom_range, 1+zoom_range] + **channel_shift_range**：浮点数，随机通道偏移的幅度 + **fill_mode**：；‘constant’，‘nearest’，‘reflect’或‘wrap’之一，当进行变换时超出边界的点将根据本参数给定的方法进行处理 + **cval**：浮点数或整数，当fill_mode=constant时，指定要向超出边界的点填充的值 + **horizontal_flip**：布尔值，进行随机水平翻转 + **vertical_flip**：布尔值，进行随机竖直翻转 + **rescale**: 重放缩因子,默认为None. 如果为None或0则不进行放缩,否则会将该数值乘到数据上(在应用其他变换之前) + `ImageDataGenerator.flow_from_directory()` ，实现了自动给固定格式目录下的数据集打标签，分批无序读取，返回张量类型数据集。 + 这个API要求有严格的目录格式，如下： + ``` data/ train/ dogs/ dog001.jpg dog002.jpg ... cats/ cat001.jpg cat002.jpg ... validation/ dogs/ dog001.jpg dog002.jpg ... cats/ cat001.jpg cat002.jpg ... ```generator = datagen.flow_from_directory( dir_path, # 数据存放路径 target_size=(img_row, img_col), # 目标形状 batch_size=batch_size, # 批数量大小 class_mode='categorical', # 二分类使用binary # \"categorical\" ：2D one-hot encoded labels # \"binary\" will be 1D binary labels shuffle=is_train # 是否打乱 ) + 参数：(参考：https://blog.csdn.net/mieleizhi0522/article/details/82191331) **directory**: 目标文件夹路径,对于每一个类,该文件夹都要包含一个子文件夹.子文件夹中任何JPG、PNG、BNP、PPM的图片都会被生成器使用.详情请查看此脚本 **target_size**: 整数tuple,默认为(256, 256). 图像将被resize成该尺寸 **color_mode**: 颜色模式,为\"grayscale\",\"rgb\"之一,默认为\"rgb\".代表这些图片是否会被转换为单通道或三通道的图片. **classes**: 可选参数,为子文件夹的列表,如['dogs','cats']默认为None. 若未提供,则该类别列表将从directory下的子文件夹名称/结构自动推断。每一个子文件夹都会被认为是一个新的类。(类别的顺序将按照字母表顺序映射到标签值)。通过属性class_indices可获得文件夹名与类的序号的对应字典。 **class_mode**: \"categorical\", \"binary\", \"sparse\"或None之一. 默认为\"categorical. 该参数决定了返回的标签数组的形式, \"categorical\"会返回2D的one-hot编码标签,\"binary\"返回1D的二值标签.\"sparse\"返回1D的整数标签,如果为None则不返回任何标签, 生成器将仅仅生成batch数据, 这种情况在使用model.predict_generator()和model.evaluate_generator()等函数时会用到. **batch_size**: batch数据的大小,默认32 **shuffle**: 是否打乱数据,默认为True **seed**: 可选参数,打乱数据和进行变换时的随机数种子 **save_to_dir**: None或字符串，该参数能让你将提升后的图片保存起来，用以可视化 **save_prefix**：字符串，保存提升后图片时使用的前缀, 仅当设置了save_to_dir时生效 **save_format**：\"png\"或\"jpeg\"之一，指定保存图片的数据格式,默认\"jpeg\" flollow_links: 是否访问子文件夹中的软链接 ## 构建InceptionV3模型 ![](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/基于InceptionV3迁移学习实现岩石图像智能识别.assets/inceptionV3网络结构图.png) Bottleneck feature即为瓶颈层输出的特征，后面的层被丢弃。我们在瓶颈层后添加全连接层进行分类，输出变为符合概率分布的概率。添加的层结构如下。 ![](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/基于InceptionV3迁移学习实现岩石图像智能识别.assets/自建层.png) 设置整体卷积神经网络的输入为（150，150，3）矩阵。 自建层输入的是3 * 3 * 2048 的张量，因为我们是分类5类图像，所以最后一层用5个神经元，使用softmax激活函数，输出五种类别各自的概率值。 **Flatten**：Flatten层用来将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。Flatten不影响batch的大小。 **Dropout**：做分类的时候，Dropout 层一般加在全连接层 防止过拟合，提升模型泛化能力。而很少见到卷积层后接Dropout（原因主要是 卷积参数少，不易过拟合） 冻结源模型的所有层，**针对数据集大小有三种不同方案：** - 数据集少的就冻住所有的特征提取层 - 数据集中的可以冻住开始一部分的特征提取层 - 数据集多的可以自行训练参数 **可视化神经网络结构**： ```python from tensorflow.keras.utils import plot_model plot_model(model, to_file='inceptionV3_model.png', show_shapes=True) def InceptionV3_model(self, lr=0.005, decay=1e-6, momentum=0.9, nb_classes=2, img_rows=197, img_cols=197, RGB=True, is_plot_model=False): \"\"\"InceptionV3模型，建立自己的模型 Args: lr (float, optional): 学习率. Defaults to 0.005. decay ([type], optional): 学习衰减率. Defaults to 1e-6. momentum (float, optional): Defaults to 0.9. nb_classes (int, optional): 分类数. Defaults to 2. img_rows (int, optional): 图片行数. Defaults to 197. img_cols (int, optional): 图片列数. Defaults to 197. RGB (bool, optional): 是否为3通道图片. Defaults to True. is_plot_model (bool, optional): 是否画出模型网络结构图. Defaults to False. Returns: [type]: 返回模型 \"\"\" color = 3 if RGB else 1 # 假设最后一层CNN的层输出为(img_rows, img_cols, color base_model = InceptionV3(weights='imagenet', include_top=False, input_shape=(img_rows, img_cols, color), ) # 对我们的输出进行平铺操作,為全連接层做准备 x = layers.Flatten()(base_model.output) # 增加一个全连接层，并使用relu作为激活函数，这是需要训练的 x = layers.Dense(1024, activation='relu')(x) # 添加随机失活，抑制过拟合 x = layers.Dropout(0.2)(x) # ，输出层，把输出设置成softmax函数 predictions = layers.Dense(nb_classes, activation='softmax')(x) # 训练模型 model = Model(inputs=base_model.input, outputs=predictions) # 冻结base_model所有层，这样就可以正确获得bottleneck特征 for layer in base_model.layers: layer.trainable = False sgd = SGD(lr=lr, decay=decay, momentum=momentum, nesterov=True) model.compile(loss='categorical_crossentropy', optimizer=sgd, metrics=['acc']) model.summary() # 可视化网络结构，生成图片 if is_plot_model: plot_model(model, to_file='inceptionV3_model.png', show_shapes=True) return model 训练、保存模型训练：用fit_generator函数，它可以避免了一次性加载大量的数据，并且生成器与模型将并行执行以提高效率。比如可以在CPU上进行实时的数据提升，同时在GPU上进行模型训练 def train_model(self, model, epochs, train_generator, steps_per_epoch, validation_generator, validation_steps,path_save_model, is_load_model=False): \"\"\"训练模型，载入、保存、断点续训 Args: model ([type]): 模型 epochs ([type]): 训练次数 train_generator ([type]): 训练集 steps_per_epoch ([type]): validation_generator ([type]): 验证集 validation_steps ([type]): path_save_model ([type]): 保存模型路径 is_load_model (bool, optional): 是否载入模型. Defaults to False. Returns: [type]: 训练记录 \"\"\" # 载入模型 if is_load_model and os.path.exists(path_save_model): print('================载入已训练模型===============') model = load_model(path_save_model) # 使用tensorboard log_dir = \"logs/fit/\" + datetime.datetime.now().strftime(\"%Y%m%d-%H%M%S\") tensorboard_callback = tf.keras.callbacks.TensorBoard( log_dir=log_dir, histogram_freq=1) # 断点续训 # 格式化字符，防止文件名冲突 checkpoint_path = 'ckpt/transfer_{epoch:02d}-{val_acc:.2f}.h5' checkpoint_callback = tf.keras.callbacks.ModelCheckpoint( checkpoint_path, # 保存路径，指定为tensorflow二进制文件ckpt monitor='val_acc', # 监测指标，这里是测试集的acc save_best_only=False, # 是否只保存最佳 save_weights_only=True, # 只保存权重 mode='max', period=1 # 每period个周期保存一次 ) # 训练 print('================开始训练================') history_ft = model.fit_generator( train_generator, steps_per_epoch=steps_per_epoch, epochs=epochs, validation_data=validation_generator, validation_steps=validation_steps, verbose=1, # 日志显示，0/1,1表示输出进度条日志信息 callbacks=[tensorboard_callback, checkpoint_callback]) # 模型保存 print('================保存模型================') model.save(path_save_model, overwrite=True) return history_ft 断点续训：在模型训练时保存检查点，防止因意外情况丢失训练进度。 # 断点续训 # 格式化字符，防止文件名冲突 checkpoint_path = 'ckpt/transfer_{epoch:02d}-{val_acc:.2f}.h5' checkpoint_callback = tf.keras.callbacks.ModelCheckpoint( checkpoint_path, # 保存路径，指定为tensorflow二进制文件ckpt monitor='val_acc', # 监测指标，这里是测试集的acc save_best_only=False, # 是否只保存最佳 save_weights_only=True, # 只保存权重 mode='max', period=1 # 每period个周期保存一次 ) 保存、载入模型的详细用法，请参考我的另一篇博客：https://blog.csdn.net/jun_zhong866810/article/details/119708120?spm=1001.2014.3001.5501 可视化acc/loss图def plot_training(self, history): \"\"\"可视化acc/loss图 Args: history ([type]): 训练 \"\"\" print('================绘制acc/loss图================') acc = history.history['acc'] val_acc = history.history['val_acc'] loss = history.history['loss'] val_loss = history.history['val_loss'] epochs = range(len(acc)) plt.plot(epochs, acc, 'b-') plt.plot(epochs, val_acc, 'r') plt.title('Training and validation accuracy') plt.figure() plt.plot(epochs, loss, 'b-') plt.plot(epochs, val_loss, 'r-') plt.title('Training and validation loss') plt.show() 预测 载入我们训练好的模型（读取全部模型或者读取权重） 输入待识别岩石图像，图像格式标准化 预测并输出对于的岩石标签 # 建立标签字典，便于输出结果 label_dict = { '0': '安山岩', '1': '石灰岩', '2': '石英岩', '3': '砾岩', '4': '花岗岩' } def loadModel(): \"\"\"读取全部模型数据\"\"\" model = tf.keras.models.load_model('model/my_saved_InceptionV3_model.h5') return model if __name__ == '__main__': model = loadModel() print(model.summary()) for img_name in os.listdir(path): img_path = path+img_name img = image.load_img(img_path, target_size=(150, 150)) # 保持输入格式一致 x = image.img_to_array(img) / 255 # 变为四维数据 x = np.expand_dims(x, axis=0) # 预测 result = model.predict(x) # 返回最大概率值的索引，类型是张量 index = tf.argmax(result, axis=1) print(img_name, '======================&gt;', label_dict[str(int(index))]) 原始图像： 源代码与数据集数据集： 链接：https://pan.baidu.com/s/15ZfB79YGxdMZwT4I3OPRiQ提取码：zjsg train.py # -*- coding: utf-8 -*- # @Time : 2021/08/15 # @Author : Z.J # @File : train.py # @Software: vs code # -*- coding: utf-8 -*- import os import datetime import tensorflow as tf import matplotlib.pyplot as plt from tensorflow.keras import layers from tensorflow.keras.utils import plot_model from tensorflow.keras.applications.inception_v3 import InceptionV3 from tensorflow.keras.models import Model, load_model from tensorflow.keras.optimizers import SGD from tensorflow.keras.preprocessing.image import ImageDataGenerator from tensorflow.keras.regularizers import l2 class PowerTransferMode: \"\"\"迁移学习类 \"\"\" def DataGen(self, dir_path, img_row, img_col, batch_size, is_train): \"\"\"读取数据集，并进行数据增强和打标签 Args: dir_path (str)): 数据集路径 img_row (int): 行数 img_col (int): 行数 batch_size (int): 批数量 is_train (bool): 是否为训练集 Returns: [type]: 数据集 \"\"\" if is_train: # ImageDataGenerator :生产图片的批次张量值并且提供数据增强功能 print('==================读取训练数据================') datagen = ImageDataGenerator(rescale=1. / 255, zoom_range=0.2, rotation_range=40., channel_shift_range=25., width_shift_range=0.2, height_shift_range=0.2, horizontal_flip=True, fill_mode='nearest') # fill_mode：‘constant’，‘nearest’，‘reflect’或‘wrap’之一， # 当进行变换时超出边界的点将根据本参数给定的方法进行处理 else: # 验证集不需要数据增强 print('==================读取验证数据================') datagen = ImageDataGenerator(rescale=1. / 255) generator = datagen.flow_from_directory( dir_path, # 数据存放路径 target_size=(img_row, img_col), # 目标形状 batch_size=batch_size, # 批数量大小 class_mode='categorical', # 二分类使用binary # \"categorical\" ：2D one-hot encoded labels # \"binary\" will be 1D binary labels shuffle=is_train # 是否打乱 ) return generator # InceptionV3模型 def InceptionV3_model(self, lr=0.005, decay=1e-6, momentum=0.9, nb_classes=2, img_rows=197, img_cols=197, RGB=True, is_plot_model=False): \"\"\"InceptionV3模型，建立自己的模型 Args: lr (float, optional): 学习率. Defaults to 0.005. decay ([type], optional): 学习衰减率. Defaults to 1e-6. momentum (float, optional): Defaults to 0.9. nb_classes (int, optional): 分类数. Defaults to 2. img_rows (int, optional): 图片行数. Defaults to 197. img_cols (int, optional): 图片列数. Defaults to 197. RGB (bool, optional): 是否为3通道图片. Defaults to True. is_plot_model (bool, optional): 是否画出模型网络结构图. Defaults to False. Returns: [type]: 返回模型 \"\"\" color = 3 if RGB else 1 # 假设最后一层CNN的层输出为(img_rows, img_cols, color) print('=================加载预训练模型=================') base_model = InceptionV3(weights='imagenet', include_top=False, input_shape=(img_rows, img_cols, color), ) # 对我们的输出进行平铺操作,為全連接层做准备 x = layers.Flatten()(base_model.output) # 增加一个全连接层，并使用relu作为激活函数，这是需要训练的 x = layers.Dense(1024, activation='relu')(x) # 添加随机失活，抑制过拟合 x = layers.Dropout(0.2)(x) # ，输出层，把输出设置成softmax函数 predictions = layers.Dense(nb_classes, activation='softmax')(x) # 训练模型 print('================创建自己的模型==================') model = Model(inputs=base_model.input, outputs=predictions) # 冻结base_model所有层，这样就可以正确获得bottleneck特征 for layer in base_model.layers: layer.trainable = False sgd = SGD(lr=lr, decay=decay, momentum=momentum, nesterov=True) print('================编译模型=================') model.compile(loss='categorical_crossentropy', optimizer=sgd, metrics=['acc']) print('=================打印模型结构信息=================') model.summary() # 可视化网络结构，生成图片 if is_plot_model: plot_model(model, to_file='inceptionV3_model.png', show_shapes=True) return model def train_model(self, model, epochs, train_generator, steps_per_epoch, validation_generator, validation_steps,path_save_model, is_load_model=False): \"\"\"训练模型，载入、保存、断点续训 Args: model ([type]): 模型 epochs ([type]): 训练次数 train_generator ([type]): 训练集 steps_per_epoch ([type]): validation_generator ([type]): 验证集 validation_steps ([type]): path_save_model ([type]): 保存模型路径 is_load_model (bool, optional): 是否载入模型. Defaults to False. Returns: [type]: 训练记录 \"\"\" # 载入模型 if is_load_model and os.path.exists(path_save_model): print('================载入已训练模型===============') model = load_model(path_save_model) # 使用tensorboard log_dir = \"logs/fit/\" + datetime.datetime.now().strftime(\"%Y%m%d-%H%M%S\") tensorboard_callback = tf.keras.callbacks.TensorBoard( log_dir=log_dir, histogram_freq=1) # 断点续训 # 格式化字符，防止文件名冲突 checkpoint_path = 'ckpt/transfer_{epoch:02d}-{val_acc:.2f}.h5' checkpoint_callback = tf.keras.callbacks.ModelCheckpoint( checkpoint_path, # 保存路径，指定为tensorflow二进制文件ckpt monitor='val_acc', # 监测指标，这里是测试集的acc save_best_only=False, # 是否只保存最佳 save_weights_only=True, # 只保存权重 mode='max', period=1 # 每period个周期保存一次 ) # 训练 print('================开始训练================') history_ft = model.fit_generator( train_generator, steps_per_epoch=steps_per_epoch, epochs=epochs, validation_data=validation_generator, validation_steps=validation_steps, verbose=1, # 日志显示，0/1,1表示输出进度条日志信息 callbacks=[tensorboard_callback, checkpoint_callback]) # 模型保存 print('================保存模型================') model.save(path_save_model, overwrite=True) return history_ft def plot_training(self, history): \"\"\"可视化acc/loss图 Args: history ([type]): 训练 \"\"\" print('================绘制acc/loss图================') acc = history.history['acc'] val_acc = history.history['val_acc'] loss = history.history['loss'] val_loss = history.history['val_loss'] epochs = range(len(acc)) plt.plot(epochs, acc, 'b-') plt.plot(epochs, val_acc, 'r') plt.title('Training and validation accuracy') plt.figure() plt.plot(epochs, loss, 'b-') plt.plot(epochs, val_loss, 'r-') plt.title('Training and validation loss') plt.show() if __name__ == '__main__': image_size = 150 batch_size = 20 num_train = 300 num_val = 100 transfer_model = PowerTransferMode() # 得到数据 train_generator = transfer_model.DataGen('./data/岩石数据集/train', image_size, image_size, batch_size, True) validation_generator = transfer_model.DataGen('./data/岩石数据集/validation', image_size, image_size, batch_size, False) # InceptionV3 model = transfer_model.InceptionV3_model(nb_classes=5, img_rows=image_size, img_cols=image_size, is_plot_model=False) # 训练模型 history_ft = transfer_model.train_model(model, epochs=50, train_generator=train_generator, steps_per_epoch=num_train / batch_size, validation_generator=validation_generator, validation_steps=num_val / batch_size, path_save_model='model/my_saved_InceptionV3_model.h5', is_load_model=True) transfer_model.plot_training(history_ft) predict.py # -*- coding: utf-8 -*- # @Time : 2021/08/15 # @Author : Z.J # @File : predict.py # @Software: vs code from tensorflow.keras.preprocessing import image import numpy as np import os import tensorflow as tf import train from tensorflow.python.training.checkpoint_management import latest_checkpoint path = \"./tmp/predict/\" # 预测图片的路径 path_save_model = './model/my_saved_InceptionV3_model.h5' # 保存的模型的路径 checkpoint_path = 'ckpt/transfer_{epoch:02d}-{val_acc:.2f}.h5' # 检查点路径 checkpoint_root = os.path.dirname(checkpoint_path) # 检查点文件根目录 image_size = 150 # 图片格式(150,150) # 建立标签字典，便于输出结果 label_dict = { '0': '安山岩', '1': '石灰岩', '2': '石英岩', '3': '砾岩', '4': '花岗岩' } def loadWeights(): \"\"\" 读取保存的权重数据，需先构建网络结构一致的新模型 \"\"\" base_model = train.PowerTransferMode() model = base_model.InceptionV3_model( nb_classes=5, img_rows=image_size, img_cols=image_size, is_plot_model=False ) # 从检查点恢复权重 saved_weights = './ckpt/transfer_50-1.00.h5' # latest_weights = tf.train.latest_checkpoint(checkpoint_root) 只对ckpt格式文件有用！ model.load_weights(saved_weights) return model def loadModel(): \"\"\"读取全部模型数据\"\"\" model = tf.keras.models.load_model('model/my_saved_InceptionV3_model.h5') return model if __name__ == '__main__': model = loadWeights() print(model.summary()) for img_name in os.listdir(path): img_path = path+img_name img = image.load_img(img_path, target_size=(150, 150)) # 保持输入格式一致 x = image.img_to_array(img) / 255 # 变为四维数据 x = np.expand_dims(x, axis=0) # 预测 result = model.predict(x) # 返回最大概率值的索引，类型是张量 index = tf.argmax(result, axis=1) print(img_name, '======================&gt;', label_dict[str(int(index))]) 参考https://blog.csdn.net/pengdali/article/details/79050662 https://blog.csdn.net/m0_46334316/article/details/117607628 感谢博主提供的岩石数据集 https://blog.csdn.net/weixin_43999137/article/details/104093095 http://www.51zixue.net/Keras/853.html https://blog.csdn.net/mieleizhi0522/article/details/82191331","categories":[{"name":"图像分类","slug":"图像分类","permalink":"https://jlexzhong.github.io/blog/categories/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://jlexzhong.github.io/blog/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/tags/tensorflow/"},{"name":"keras","slug":"keras","permalink":"https://jlexzhong.github.io/blog/tags/keras/"},{"name":"图像分类","slug":"图像分类","permalink":"https://jlexzhong.github.io/blog/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"}]},{"title":"Python批量删除含有指定字符的文件或文件夹","slug":"Python-batch-delet-files","date":"2021-08-30T15:18:38.000Z","updated":"2021-09-14T02:21:39.734Z","comments":true,"path":"2021/08/30/Python-batch-delet-files/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/30/Python-batch-delet-files/","excerpt":"","text":"Python批量删除含有指定字符的文件或文件夹# encoding: UTF-8 import os from pathlib import Path p = Path(r'./test/erli') # 这里不得不感慨，Python的库，几乎满足你所有需要，看，连这个递归查找过滤都有了！ # 实现思路：递归遍历文件夹中的文件，如果文件名包含\"(-)\"，就删掉，下面是代码： for file in p.rglob('*(-)*'): if os.path.isfile(file): #这里判断下，如果是文件夹就先不删 os.remove(file) 参考： https://www.jianshu.com/p/17ae57c19d1d","categories":[{"name":"python","slug":"python","permalink":"https://jlexzhong.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jlexzhong.github.io/blog/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://jlexzhong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pyqt5小记| QSS开源暗黑主题qdarkstyle ，读取QSS主题文件","slug":"pyqt5-QSS-qdarkstyle","date":"2021-08-30T15:17:11.000Z","updated":"2021-09-14T02:21:10.521Z","comments":true,"path":"2021/08/30/pyqt5-QSS-qdarkstyle/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/30/pyqt5-QSS-qdarkstyle/","excerpt":"","text":"pyqt5小记| QSS开源暗黑主题qdarkstyle ，读取QSS主题文件安装Pip install qdarkstyle 使用import sys from PyQt5.QtGui import QIcon import qdarkstyle from PyQt5 import QtCore from PyQt5.QtWidgets import QApplication, QMainWindow if __name__ == '__main__': app = QApplication(sys.argv) app.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling) # 适应高分辨率 # qdarkstyle # 设置qdarkstyle！！！ app.setStyleSheet(qdarkstyle.load_stylesheet()) # myMainWindow = QMainWindow() myUi = wMain.Ui_MainWindow() myUi.setupUi(myMainWindow) myMainWindow.setWindowTitle('ZDEMViewer 离散元数值模拟可视化程序') myMainWindow.setWindowIcon(QIcon(\"./icons/logo.ico\")) myMainWindow.show() sys.exit(app.exec_()) 效果![](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/pyqt5 QSS开源暗黑主题qdarkstyle.assets/暗黑主题 2021-08-19 113230.png) 如何读取QSS文件作为GUI主题with open('./QSS/myQSS.qss', encoding='utf-8') as f: qss = f.read() app.setStyleSheet(qss) # 设置主题","categories":[],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/tags/PyQt/"},{"name":"GUI","slug":"GUI","permalink":"https://jlexzhong.github.io/blog/tags/GUI/"}]},{"title":"pyqt5 setWindowTitle 设置窗口标题失效解决办法","slug":"pyqt5-setWindowTitle","date":"2021-08-30T15:16:45.000Z","updated":"2021-09-14T02:21:23.464Z","comments":true,"path":"2021/08/30/pyqt5-setWindowTitle/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/30/pyqt5-setWindowTitle/","excerpt":"","text":"pyqt5 setWindowTitle 设置窗口标题失效解决办法myMainWindow = QMainWindow() myUi = wMain.Ui_MainWindow() myUi.setupUi(myMainWindow) myMainWindow.setWindowTitle('ZDEMViewer 离散元数值模拟可视化程序') myMainWindow.setWindowIcon(QIcon(\"./icons/logo.ico\")) myMainWindow.show() 如上所示的设置顺序可以成功 如果是： myMainWindow = QMainWindow() myMainWindow.setWindowTitle('ZDEMViewer 离散元数值模拟可视化程序') myMainWindow.setWindowIcon(QIcon(\"./icons/logo.ico\")) myUi = wMain.Ui_MainWindow() myUi.setupUi(myMainWindow) myMainWindow.show() 会出现图标能够生效，但是标题在生效之后一闪而过，变为“MainWindow”","categories":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/tags/PyQt/"},{"name":"GUI","slug":"GUI","permalink":"https://jlexzhong.github.io/blog/tags/GUI/"}]},{"title":"pyqtgraph嵌入pyqt界面中 | 修改pyqtgraph背景颜色 | 坐标轴等比例缩放","slug":"pyqtgraph-to-pyqt-background-axes-square","date":"2021-08-30T15:16:16.000Z","updated":"2021-09-14T02:18:22.937Z","comments":true,"path":"2021/08/30/pyqtgraph-to-pyqt-background-axes-square/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/30/pyqtgraph-to-pyqt-background-axes-square/","excerpt":"","text":"pyqtgraph嵌入pyqt界面中 | 修改pyqtgraph背景颜色 | 坐标轴等比例缩放class pyqtgraph_widget(QWidget): \"\"\"将pyqtgraph嵌入到pyqt界面中 Args: QWidget ([type]): 基于QWidget组件 \"\"\" def __init__(self, parent=None): \"\"\" :param parent: 父组件 \"\"\" QWidget.__init__(self, parent) # 创建垂直布局 self.layout = QtWidgets.QVBoxLayout(self) self.layout.setObjectName('layout') self.layout.setContentsMargins(0,0,0,0) # 修改背景颜色 pg.setConfigOption('background', '#FFFFFF') pg.setConfigOption('foreground', 'k') self.plot_widget = pg.PlotWidget() self.layout.addWidget(self.plot_widget) self.plot_widget.setAspectLocked() # 坐标轴等比例缩放","categories":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/tags/PyQt/"},{"name":"GUI","slug":"GUI","permalink":"https://jlexzhong.github.io/blog/tags/GUI/"},{"name":"pyqtgraph","slug":"pyqtgraph","permalink":"https://jlexzhong.github.io/blog/tags/pyqtgraph/"}]},{"title":"pyqt小记|侧边栏（QListWidget+QStackedWidget）实现","slug":"pyqt-listbar-QListWidget+QStackedWidget","date":"2021-08-30T15:13:54.000Z","updated":"2021-09-14T02:19:38.654Z","comments":true,"path":"2021/08/30/pyqt-listbar-QListWidget+QStackedWidget/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/30/pyqt-listbar-QListWidget+QStackedWidget/","excerpt":"","text":"pyqt小记|侧边栏（QListWidget+QStackedWidget）实现效果![](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/pyqt小记侧边栏（QListWidget+QStackedWidget）实现.assets/2021-08-19 112919.png) 思路 左边是listwidget，右边是stackedwidget。 点击listwidget的不同item，跳转到stackedwidget不同的页面。 最后通过qss美化。 实现初始化界面def init_leftWidget(self): # self.leftFrame是父组件 self.leftFrame_HLayout = QtWidgets.QHBoxLayout(self.leftFrame) self.leftFrame_HLayout.setSpacing(0) self.leftFrame_HLayout.setContentsMargins(0,0,0,0) self.leftFrame_HLayout.setAlignment(QtCore.Qt.AlignCenter) # 实例化两个组件 self.left_list_widget = QtWidgets.QListWidget(self.leftFrame) self.left_stacked_widget = QtWidgets.QStackedWidget(self.leftFrame) self.left_stacked_widget.setContentsMargins(0,0,0,0) self.leftFrame_HLayout.addWidget(self.left_list_widget) self.leftFrame_HLayout.addWidget(self.left_stacked_widget) self.left_list_widget.setFrameShape(QtWidgets.QListWidget.NoFrame) # 去除边框 self.left_list_widget.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff) # 隐藏垂直滚动条 self.left_list_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)# 隐藏水平滚动条 # 设置字体 font_1 = QtGui.QFont() font_1.setFamily(\"黑体\") font_1.setPointSize(12) font_1.setBold(False) self.left_list_widget.setFont(font_1) # 文件管理 dataView_icon = QtGui.QIcon() dataView_icon.addPixmap(QtGui.QPixmap(\"./icons/dataView.png\"), QtGui.QIcon.Normal, QtGui.QIcon.Off) self.dataView_item = QtWidgets.QListWidgetItem(dataView_icon,'文件管理',self.left_list_widget) self.dataView_item.setSizeHint(QSize(30,60)) self.dataView_item.setTextAlignment(QtCore.Qt.AlignCenter) # 数据信息 dataLog_icon = QtGui.QIcon() dataLog_icon.addPixmap(QtGui.QPixmap(\"./icons/dataLog.png\"), QtGui.QIcon.Normal, QtGui.QIcon.Off) self.dataLog_item = QtWidgets.QListWidgetItem(dataLog_icon,'数据信息',self.left_list_widget) self.dataLog_item.setSizeHint(QSize(30,60)) self.dataLog_item.setTextAlignment(QtCore.Qt.AlignCenter) # 图像参数 param_icon = QtGui.QIcon() param_icon.addPixmap(QtGui.QPixmap(\"./icons/figureParam.png\"), QtGui.QIcon.Normal, QtGui.QIcon.Off) self.param_item = QtWidgets.QListWidgetItem(param_icon,'图像参数',self.left_list_widget) self.param_item.setSizeHint(QSize(30,60)) self.param_item.setTextAlignment(QtCore.Qt.AlignCenter) # 导出 export_icon = QtGui.QIcon() export_icon.addPixmap(QtGui.QPixmap(\"./icons/save.png\"), QtGui.QIcon.Normal, QtGui.QIcon.Off) self.export_item = QtWidgets.QListWidgetItem(export_icon,'导出',self.left_list_widget) self.export_item.setSizeHint(QSize(30,60)) self.export_item.setTextAlignment(QtCore.Qt.AlignCenter) self.export_item.whatsThis() # 为listitem添加点击事件，切换stackedwidget页面 self.left_list_widget.itemClicked.connect(self.item_clicked) 点击事件，实现窗口的切换def item_clicked(self): # 获取当前选中的item item = self.left_list_widget.selectedItems()[0] if item.text() == '文件管理': self.switch_dataView() elif (item.text() == '数据信息'): self.switch_dataLog() elif item.text() == '图像参数': self.switch_paramWidget() else: self.switch_export() QSS美化.qss文件： QListWidget, QListView, QTreeWidget, QTreeView { outline: 0px; } QListWidget { min-width: 120px; max-width: 120px; color: Black; background: #F5F5F5; } QListWidget::Item:hover { background: rgb(255, 255, 255); border-left: 5px solid rgb(112, 66, 219); } QListWidget::Item:selected { background: lightGray; border-left: 5px solid rgb(112, 66, 219); } HistoryPanel:hover { background: rgb(52, 52, 52); }","categories":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/tags/PyQt/"},{"name":"GUI","slug":"GUI","permalink":"https://jlexzhong.github.io/blog/tags/GUI/"}]},{"title":"pyqy小记|生成gif并嵌入到GUI中","slug":"pyqy-compose-gif-to-gui","date":"2021-08-30T15:13:27.000Z","updated":"2021-09-14T02:18:03.776Z","comments":true,"path":"2021/08/30/pyqy-compose-gif-to-gui/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/30/pyqy-compose-gif-to-gui/","excerpt":"","text":"pyqy小记|生成gif并嵌入到GUI中生成gif，嵌入到标签QLabel中def compose_gif(self): \"\"\"生成gif \"\"\" jpgPath_List = [] # 读取图片集 jpgList = os.listdir(\"./temp save files\") # 参数是图片集存放的路径，返回该路径下的所有文件名 for jpgName in jpgList: absolutePath = os.path.join(\"./temp save files/\", jpgName) # 拼接成绝对路径 jpgPath_List.append(absolutePath) gif_images = [] # 读取单个图片，将数据存入列表中 for path in jpgPath_List: gif_images.append(imageio.imread(path)) #保存为gif，fps=2 imageio.mimsave(\"./temp save files/test.gif\", gif_images, fps=2) # 实例化QMovie self.gif = QMovie('./temp save files/test.gif') # tabwidget增加一页 gif_tab = QtWidgets.QWidget() gif_tab.setObjectName('gif_tab') self.tabWidget.addTab(gif_tab, 'GIF') gif_verticalLAYOUT = QtWidgets.QVBoxLayout(gif_tab) # gif_verticalLAYOUT.setObjectName('gif_verticalLAYOUT') # 用gifLabel展示gif self.gifLabel = QtWidgets.QLabel(gif_tab) self.gifLabel.setObjectName('gifLabel') gif_verticalLAYOUT.addWidget(self.gifLabel) self.tabWidget.setCurrentWidget(gif_tab) # 设置当前页为gif播放tab # 把gif嵌入到label self.gifLabel.setMovie(self.gif) self.gif.start() self.gifLabel.show() 播放/暂停gifdef pauseGif(self): self.gif.setPaused(True) def playGif(self): self.gif.setPaused(False)","categories":[],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/tags/PyQt/"},{"name":"GUI","slug":"GUI","permalink":"https://jlexzhong.github.io/blog/tags/GUI/"}]},{"title":"🎃一个坏掉的番茄个人主页——魔改教程、遇坑总结","slug":"tomotoes_blog","date":"2021-08-30T10:09:42.000Z","updated":"2021-09-14T02:22:20.536Z","comments":true,"path":"2021/08/30/tomotoes_blog/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/30/tomotoes_blog/","excerpt":"","text":"🎃一个坏掉的番茄个人主页——魔改教程、遇坑总结主页模板地址：https://github.com/Tomotoes/HomePage 中文使用文档：https://github.com/Tomotoes/HomePage/blob/master/README.zh_CN.md 配置步骤在作者的使用文档中写的以及非常详细了，我总结一下如何自定义。 标题、文字、头像在config.json { \"head\": { \"title\": \"钟军的小黑板\", \"description\": \"Author:Jlex Zhong,Category:Personal Blog\", \"favicon\": \"favicon.ico\" // 暂未找到网站图标的修改方法 }, \"intro\": { \"title\": \"Jlex Zhong\", \"subtitle\": \"Wellcome to my HomePage\", \"enter\": \"enter\", \"supportAuthor\": true, \"background\": true }, \"main\": { \"name\": \"Jlex Zhong\", \"signature\": \"向日葵晚上在干啥呢？\", \"avatar\": { \"link\": \"assets/avatar.jpg\", // 头像，将路径下的图片替换即可 \"height\": \"100\", \"width\": \"100\" }, 增加页面在config.json中 \"ul\": { \"first\": { \"href\": \"blog/\", \"icon\": \"blog\", \"text\": \"Blog\" }, \"second\": { \"href\": \"blog/about/\", \"icon\": \"guanyuwo\", \"text\": \"About Me\" }, \"third\": { \"href\": \"mailto:junzhong0917@163.com\", \"icon\": \"email\", \"text\": \"Email\" }, \"fourth\": { \"href\": \"blog/about/\", //我添加的页面 \"icon\": \"AIRESEARCH\", \"text\": \"AI Lab\" }, \"five\": { \"href\": \"https://github.com/JlexZhong\", \"icon\": \"github\", \"text\": \"Github\" } 在src\\components\\main.pug ul li a(href=`${first.href}` aria-label=`${first.text}`) i(class=`icon icon-${first.icon}`) span(data-translate=`${first.text}`) #{first.text} li a(href=`${second.href}` aria-label=`${second.text}`) i(class=`icon icon-${second.icon}`) span(data-translate=`${second.text}`) #{second.text} li a(href=`${third.href}` aria-label=`${third.text}` target=\"_blank\") i(class=`icon icon-${third.icon}`) span(data-translate=`${third.text}`) #{third.text} li a(href=`${fourth.href}` aria-label=`${fourth.text}` target=\"_blank\") i(class=`icon icon-${fourth.icon}`) span(data-translate=`${fourth.text}`) #{fourth.text} li a(href=`${five.href}` aria-label=`${five.text}` target=\"_blank\") i(class=`icon icon-${five.icon}`) span(data-translate=`${five.text}`) #{five.text} 更换图标 到阿里矢量图标网站中找到自己的图标，并添加到一个项目中。https://www.iconfont.cn/ 把图标调成白色 进入项目设置，把这些勾选上 点击Font Class, 查看在线链接，点击该链接 复制链接中的所有内容，除了以下部分，其余全部替换掉。 .icon { display: block; width: 1.5em; height: 1.5em; margin: 0 auto; fill: currentColor; font-family: 'iconfont' !important; font-size: inherit; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } 最后去config.json中修改图标的名称，不用加icon-。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://jlexzhong.github.io/blog/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://jlexzhong.github.io/blog/tags/hexo/"}]},{"title":"pyqt小记|matplotlib嵌入pyqt界面|添加工具条 | matplotlib保存太慢解决方法","slug":"pyqt-matplotlib-to-pyqt-add-toolbar-matplotlib-save-too-slowly","date":"2021-08-29T15:14:23.000Z","updated":"2021-09-14T02:20:53.850Z","comments":true,"path":"2021/08/29/pyqt-matplotlib-to-pyqt-add-toolbar-matplotlib-save-too-slowly/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/29/pyqt-matplotlib-to-pyqt-add-toolbar-matplotlib-save-too-slowly/","excerpt":"","text":"pyqt小记|matplotlib嵌入pyqt界面|添加工具条 | matplotlib保存太慢解决方法上源码： from PyQt5 import QtWidgets from matplotlib.figure import Figure from matplotlib.backends.backend_qt5 import NavigationToolbar2QT as NavigationToolbar from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg # pyqt5的画布 import io import cv2 import matplotlib import numpy as np from PIL import Image from PyQt5.QtWidgets import QWidget matplotlib.use(\"Qt5Agg\") # 声明使用pyqt5 class MatplotlibFigure(FigureCanvasQTAgg): \"\"\" 创建一个画布类，并把画布放到FigureCanvasQTAgg \"\"\" def __init__(self, parent=None, filePrefix=None): \"\"\" :param parent: :param filePrefix: \"\"\" self.figs = Figure(figsize=(10, 8), dpi=200) super(MatplotlibFigure, self).__init__(self.figs) # 在父类中激活self.fig self.setParent(parent) self.filePrefix = filePrefix self.axes = self.figs.add_subplot(111) self.axes.patch.set_alpha(1) # 设置ax区域背景颜色透明度 # self.figs.canvas.setStyleSheet(\"background-color:transparent;\") FigureCanvasQTAgg.setSizePolicy( self, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding) # 用于告知包含该widget的layout：该widget的size hint已发生变化，layout会自动进行调整。 FigureCanvasQTAgg.updateGeometry(self) def saveFig(self): \"\"\" 保存图片，使用二进制字节流存储，opencv读取。速度优秀 \"\"\" buffer = io.BytesIO() # 字节流对象 self.figs.canvas.print_png(buffer) # 把画布写入字节流 data = buffer.getvalue() buffer.write(data) img = Image.open(buffer) img = np.asarray(img) img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) cv2.imwrite(\"./temp save files/\" + self.filePrefix + \".png\", img) def saveFig2(self): \"\"\" FIXME:需要优化保存图片的速度 \"\"\" self.figs.savefig(\"./temp save files/\" + self.filePrefix + \".jpg\", dpi=144, bbox_inches=\"tight\") class MplWidget(QWidget): \"\"\"Qt控件，用于嵌入matplotlib画布和工具栏 Args: QWidget ([type]): [description] \"\"\" def __init__(self, parent=None, filePrefix=None): \"\"\" :param parent: \"\"\" QWidget.__init__(self, parent) self.qCanvas = MatplotlibFigure(parent, filePrefix) self.mpl_toolbar = NavigationToolbar(self.qCanvas, self) # 创建工具条 # 创建布局，把画布类组件对象和工具条对象添加到QWidget控件中 self.vbl = QtWidgets.QVBoxLayout(self) self.vbl.addWidget(self.qCanvas) self.vbl.addWidget(self.mpl_toolbar)","categories":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/tags/PyQt/"},{"name":"GUI","slug":"GUI","permalink":"https://jlexzhong.github.io/blog/tags/GUI/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://jlexzhong.github.io/blog/tags/matplotlib/"}]},{"title":"HTML学习笔记","slug":"HTML-note","date":"2021-08-29T04:22:09.000Z","updated":"2021-09-14T02:18:41.245Z","comments":true,"path":"2021/08/29/HTML-note/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/29/HTML-note/","excerpt":"","text":"HTML 学习笔记&lt;li&gt;定义列表。 ““：有序列表； ““：无序列表。 &lt;a&gt;定义超链接 id,name,class的理解 id、name、class属性是什么？ id是html页面中元素的唯一标示，属性值在页面中不能重复，每个元素的id不同，可以设置也可以不设置； name属性值可以重复，指的是标签的名称； class可简单的理解为类属性，属性值在页面中不唯一； id、name、class的用途 id是标签的唯一标识，多用于js脚本中，比如页面中有多个元素，让我们想在js脚本中对某个特定元素进行设置的时候，我们可以根据id来直接访问该元素。同时，id也可用于css样式中，当我们想对某个单独的元素做出改变样式时候可以进行设置，使用 #元素id{ } 方式来改变样式 name多用于表单中，用来和服务器进行交互，如CheckBox标签和radio标签等，对应的name属性的值就是提交表单后变量的名称。 class多用于设置CSS样式 ，当我们想让很多元素拥有相同的样式时，可以通过class属性的值来统一选择，通常为 .class的属性{} 设置css样式做法一般是先通过类设置大部分相同的元素样式，再通过ID设置独特的元素样式。 &lt;a&gt;中的 target=”_blank”属性 _blank – 在新窗口中打开链接 _parent – 在父窗体中打开链接 _self – 在当前窗体打开链接,此为默认值 _top – 在当前窗体打开链接，并替换当前的整个窗体(框架页) 一个对应的框架页的名称 – 在对应框架页中打开 data-aoc&lt;div data-aos=\"fade-up\"&gt; 平滑上升效果 BUG：Uncaught ReferenceError: $ is not defined使用CDN地址引用jQuery &lt;script src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt; HTML中返回上级目录的写法当前目录：https://jlexzhong.github.io/blog/ 返回上级应该为：href=\"../index.html\" https://www.cnblogs.com/kenshinobiy/p/7783135.html","categories":[{"name":"HTML","slug":"HTML","permalink":"https://jlexzhong.github.io/blog/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://jlexzhong.github.io/blog/tags/HTML/"}]},{"title":"pyqt小记|窗口阴影、透明、无边框","slug":"pyqt-shadow-frameless","date":"2021-08-27T15:14:23.000Z","updated":"2021-09-14T02:20:50.452Z","comments":true,"path":"2021/08/27/pyqt-shadow-frameless/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/27/pyqt-shadow-frameless/","excerpt":"","text":"pyqt小记|窗口阴影、透明、无边框# 设置无边框圆角带阴影窗口 self.MainWindow.setWindowFlag(QtCore.Qt.FramelessWindowHint) # 无边框 # ===============透明阴影==================== self.MainWindow.setAutoFillBackground(True) #一定要加上 self.MainWindow.setAttribute(QtCore.Qt.WA_TranslucentBackground) # 窗口透明 shadow=QGraphicsDropShadowEffect() # 创建阴影 shadow.setBlurRadius(20) # 设置阴影大小为9px shadow.setColor(QColor(\"#444444\")) # 设置颜色透明度为100的（0,0,0）黑色 shadow.setOffset(0,0) # 阴影偏移距离为0px self.MainWindow.setGraphicsEffect(shadow) # 添加阴影 self.MainWindow.resize(1600, 900)","categories":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/tags/PyQt/"},{"name":"GUI","slug":"GUI","permalink":"https://jlexzhong.github.io/blog/tags/GUI/"}]},{"title":"Hexo+Github+matery免费搭建个人博客教程","slug":"Building-a-Blog","date":"2021-08-23T04:22:09.000Z","updated":"2021-08-30T14:40:37.000Z","comments":true,"path":"2021/08/23/Building-a-Blog/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/23/Building-a-Blog/","excerpt":"","text":"Hexo+Github免费搭建个人博客详细教程效果图 安装安装Node.js安装Node.js，一直默认。输入：（查看是否安装正确） ```node -v - 添加环境变量：**C:\\Program Files\\nodejs\\ ** - 环境变量：**C:\\Users\\26780\\AppData\\Roaming\\npm** ### 配置npm 查看**npm**是否安装成功： npm -v - 出现**BUG**： npm install出现一直停留在“fetchMetadata: sill resolveWithNewModule find-cache-dir@“ - 解决：更换国内镜像源 更换成淘宝的源npm config set registry https://registry.npm.taobao.org– 配置后可通过下面方式来验证是否成功npm config get registry– 或npm info express ### 安装**hexo** npm config set registry https://registry.npm.taobao.orgnpm install -g hexo-cli - 若出现warning，这是募捐提示，忽略即可 - ``` run `npm fund` for details 如果不想看到，输入命令： ```npm install –no-fund ### 安装git **Github**安装，教程网上很多请自行寻找，并配置好**SSH-Key** ## Hexo搭建 1. 建立空文件夹，我的是Blog，将来会在这个文件夹内存放与博客有关的内容 2. 打开GIt Bash 或者命令行，输入： hexo init 3. 文件夹内会出现一些配置文件 - `node_modules:` 依赖包 - `public：`存放生成的页面 - `scaffolds：`生成文章的一些模板 - `source：`用来存放你的文章 - `themes：`**主题** - `_config.yml:` 博客的**配置文件** 4. 执行： hexo new hello Hexo //新建一篇名为”hello Hexo”的博客 hexo g //生成静态文件 hexo s //本地部署预览 5. 会输出： INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 可能会出现加载不了的情况，因为4000端口太常用了，导致冲突。使用： hexo server -p 5000 //更改端口 6. **hexo常用命令**（参考：https://blog.csdn.net/weixin_42334475/article/details/101055364?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control） - 初始化 npm install hexo -g //安装Hexo npm update hexo -g //升级 hexo init //初始化博客 - 命令简写 hexo n “我的博客” = hexo new “我的博客” //新建文章 hexo g = hexo generate //生成 hexo s = hexo server //启动服务预览 hexo d = hexo deploy //部署 - 其他 hexo server //Hexo会监视文件变动并自动更新，无须重启服务器 hexo server -s //静态模式 hexo server -p 5000 //更改端口 hexo server -i 192.168.1.1 //自定义 IP hexo clean //清除缓存，若是网页正常情况下可以忽略这条命令 ## 推送网站 1. 修改Blog文件夹下的**_config.yml**，在末尾修改成如下格式： DeploymentDocs: https://hexo.io/docs/one-command-deployment deploy: type: git repo: https://github.com/JlexZhong/JlexZhong.github.io.git branch: main repo后的地址就是博客仓库的https地址 2. 安装git部署插件： npm install hexo-deployer-git –save 3. 然后输入命令： hexo clean //清理静态文件 hexo g //生成静态文件 hexo d //部署 4. 出现**bug**： remote: Permission to JlexZhong/JlexZhong.github.io.git denied to junz2001. fatal: unable to access ‘https://github.com/JlexZhong/JlexZhong.github.io.git/': The requested URL returned error: 403 \u001b[41mFATAL\u001b[49m { err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (E:\\Blog\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (events.js:400:28) at ChildProcess.cp.emit (E:\\Blog\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) { code: 128 } } Something’s wrong. Maybe you can find the solution here: %s \u001b[4mhttps://hexo.io/docs/troubleshooting.html\u001b[24m 解决： - 如果不是代理问题，在_config.yml文件中把repo：后的地址改为git@github.com:JlexZhong/JlexZhong.github.io.git - 是代理问题，清除代理 5. 此时博客已经上线啦！可以通过网络访问了。浏览器输入博客网站地址**xxxx.github.io** 6. **修改域名**： 现在你的个人网站的地址是`yourname.github.io`，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。 &gt; 我没有选择购买域名，等后期再来更新吧 ### 发布博客： - 先`hexo new post \"article title\"`新建一篇文章， - 在博客文件夹，`Blog/source/_posts`目录下回多出一个Markdown文件，编写完markdown文件后，保存 - 根目录下输入`hexo g`生成静态网页 - 然后输入`hexo s`可以本地预览效果 - 最后输入`hexo d`上传到`github`上 ### `_config.yml`**文件的修改建议**： - 请修改 `_config.yml` 的 `url` 的值为你的网站主 `URL`（如：`http://xxx.github.io`）。 - 建议修改两个 `per_page` 的分页条数值为 `6` 的倍数，如：`12`、`18` 等，这样文章列表在各个屏幕下都能较好的显示。 - 如果你是中文用户，则建议修改 `language` 的值为 `zh-CN`。 - `subtitle`选项：在我使用的主题当中即为网页首页中间的字体块，若为空将显示为**subtitle** - `post_asset_folder`选项设置为：true。当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。 ## 文章Front-matter `Front-matter` 是`md`文件最上方以 `---`分隔的区域，用于指定个别文件的变量.`Front-matter` 选项中的所有内容均为**非必填**的。但我仍然建议至少填写 `title` 和 `date` 的值。 ### 选项详解 | 配置选项 | 默认值 | 描述 | | ------------- | ------------------------------ | ------------------------------------------------------------ | | title | `Markdown` 的文件标题 | 文章标题，强烈建议填写此选项 | | date | 文件创建时的日期时间 | 发布时间，强烈建议填写此选项，且最好保证全局唯一 | | author | 根 `_config.yml` 中的 `author` | 文章作者 | | img | `featureImages` 中的某个值 | 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: `http://xxx.com/xxx.jpg` | | top | `true` | 推荐文章（文章是否置顶），如果 `top` 值为 `true`，则会作为首页推荐文章 | | hide | `false` | 隐藏文章，如果`hide`值为`true`，则文章不会在首页显示 | | cover | `false` | `v1.0.2`版本新增，表示该文章是否需要加入到首页轮播封面中 | | coverImg | 无 | `v1.0.2`版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 | | password | 无 | 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 `password` 的值，该值必须是用 `SHA256` 加密后的密码，防止被他人识破。前提是在主题的 `config.yml` 中激活了 `verifyPassword` 选项 | | toc | `true` | 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 `config.yml` 中激活了 `toc` 选项 | | mathjax | `false` | 是否开启数学公式支持 ，本文章是否开启 `mathjax`，且需要在主题的 `_config.yml` 文件中也需要开启才行 | | summary | 无 | 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 | | categories | 无 | 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 | | tags | 无 | 文章标签，一篇文章可以多个标签 | | keywords | 文章标题 | 文章关键字，SEO 时需要 | | reprintPolicy | cc_by | 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 | &gt; **注意**: &gt; &gt; 1. 如果 `img` 属性不填写的话，文章特色图会根据文章标题的 `hashcode` 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图**各有特色**。 &gt; 2. `date` 的值尽量保证每篇文章是唯一的，因为本主题中 `Gitalk` 和 `Gitment` 识别 `id` 是通过 `date` 的值来作为唯一标识的。 &gt; 3. 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 `_config.yml` 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：[开源中国在线工具](http://tool.oschina.net/encrypt?type=2)、[chahuo](http://encode.chahuo.com/)、[站长工具](http://tool.chinaz.com/tools/hash.aspx)。 &gt; 4. 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 `Front-matter` 示例。 ### 最简示例 ```yaml --- title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 --- 最全示例--- title: 我的第一篇博客 date: 2021-08-24 09:25:00 author: 钟军 img: /source/images/xxx.jpg top: true hide: false cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown --- 主题美化 在哪找？ https://hexo.io/themes/ cd 进blog文件夹根目录，输入： git clone 主题http链接 themes/主题名称 主题会下载到themes文件夹下。 我用的是https://github.com/blinkfox/hexo-theme-matery，主题名称是blinkfox，所以输入： git clone https://github.com/blinkfox/hexo-theme-matery themes/blinkfox 在下载的主题文件夹内有使用文档，中英文版本十分友好。 切换主题，找到根目录的_config.yml，将landscape改为blinkfox，也就是改为我们下载的主题名字： # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: landscape 然后再次部署网站，hexo g，hexo d 主题更多个性化我们可以通过修改根目录或者主题目录下的_config.yml，实现更多的个性化。当然，不同的主题的语法还有不同，修改方法请参考各主题的使用文档。例如： 代码高亮 从 Hexo5.0 版本开始自带了 prismjs 代码语法高亮的支持，本主题对此进行了改造支持。 如果你的博客中曾经安装过 hexo-prism-plugin 的插件，那么你须要执行 npm uninstall hexo-prism-plugin 来卸载掉它，否则生成的代码中会有 &amp;#123; 和 &amp;#125; 的转义字符。 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并将 prismjs.enable 的值设置为 true，主要配置如下： highlight: enable: false line_number: true auto_detect: false tab_replace: '' wrap: true hljs: false prismjs: enable: true preprocess: true line_number: true tab_replace: '' 文章字数统计插件（建议安装） 如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 更多请查看主题使用文档 Github &amp; Coding Pages 双部署后续更新 总结看到这里，相信您已经搭建出自己的个人博客网站了！","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://jlexzhong.github.io/blog/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"搭建博客","slug":"搭建博客","permalink":"https://jlexzhong.github.io/blog/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","permalink":"https://jlexzhong.github.io/blog/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://jlexzhong.github.io/blog/tags/github/"},{"name":"matery","slug":"matery","permalink":"https://jlexzhong.github.io/blog/tags/matery/"}]},{"title":"inception-resnet-v2超参数优化笔记","slug":"inception-resnet-v2-Parameter-optimization-note","date":"2021-08-19T10:00:09.000Z","updated":"2021-09-14T02:18:38.912Z","comments":true,"path":"2021/08/19/inception-resnet-v2-Parameter-optimization-note/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/19/inception-resnet-v2-Parameter-optimization-note/","excerpt":"","text":"inception-resnet-v2优化笔记csdn岩石数据集1 image_size = 299 batch_size = 32 num_train = 250 num_val = 50 epochs = 30 model.compile(loss=tf.keras.losses.CategoricalCrossentropy(from_logits=False), # BUG：交叉熵损失函数 optimizer=tf.keras.optimizers.Adam(lr=0.001, beta_1=0.9, beta_2=0.999), metrics=['accuracy']) x = layers.Dropout(0.5)(x) ![](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/inception-resnet-v2超参数优化记录.assets/2021-08-20-i and r 2 acc.png) ![](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/inception-resnet-v2超参数优化记录.assets/2021-08-20-i and r 2 loss.png) 2在1的基础上 x = layers.Dropout(0.4)(x) reduce_lr = tf.keras.callbacks.ReduceLROnPlateau(monitor='val_loss', patience=15, verbose=1,mode='auto') 3x = layers.Dropout(0.3)(x) lr=0.001, decay=0.0002, momentum=0.9 sgd = SGD(lr=lr, decay=decay, momentum=momentum, nesterov=True) print('================编译模型=================') model.compile(loss=tf.keras.losses.CategoricalCrossentropy(from_logits=False), # BUG：交叉熵损失函数 optimizer=sgd, #tf.keras.optimizers.Adam(lr=0.001, beta_1=0.9, beta_2=0.999) metrics=['accuracy']) # 动态更改学习率 reduce_lr = tf.keras.callbacks.ReduceLROnPlateau() ![](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/inception-resnet-v2超参数优化记录.assets/08-20-i r sgd -loss.png)![](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/inception-resnet-v2超参数优化记录.assets/08-20-i r sgd -acc.png) scidbk镜下矿物薄片图像数据集1总计：989 train:796 val:147 test:46 lr=0.001, decay=0.0002, momentum=0.9 sgd = SGD(lr=lr, decay=decay, momentum=momentum, nesterov=True) reduce_lr = tf.keras.callbacks.ReduceLROnPlateau() x = layers.Dropout(0.4)(x) 24/24 [==============================] - 374s 14s/step - loss: 2.1553 - accuracy: 0.4824 - val_loss: 0.7156 - val_accuracy: 0.7823 Epoch 2/30 24/24 [==============================] - 352s 14s/step - loss: 0.7679 - accuracy: 0.7475 - val_loss: 0.3818 - val_accuracy: 0.8503 Epoch 3/30 24/24 [==============================] - 290s 12s/step - loss: 0.4792 - accuracy: 0.8354 - val_loss: 0.3833 - val_accuracy: 0.8503 Epoch 4/30 24/24 [==============================] - 280s 11s/step - loss: 0.3891 - accuracy: 0.8693 - val_loss: 0.2691 - val_accuracy: 0.9048 Epoch 5/30 24/24 [==============================] - 331s 13s/step - loss: 0.2923 - accuracy: 0.8995 - val_loss: 0.2480 - val_accuracy: 0.8980 Epoch 6/30 24/24 [==============================] - 371s 15s/step - loss: 0.2635 - accuracy: 0.9133 - val_loss: 0.1679 - val_accuracy: 0.9388 Epoch 7/30 24/24 [==============================] - 374s 15s/step - loss: 0.3156 - accuracy: 0.8869 - val_loss: 0.1656 - val_accuracy: 0.9524 Epoch 8/30 24/24 [==============================] - 355s 14s/step - loss: 0.2576 - accuracy: 0.9146 - val_loss: 0.2341 - val_accuracy: 0.9116 Epoch 9/30 24/24 [==============================] - 365s 15s/step - loss: 0.2239 - accuracy: 0.9347 - val_loss: 0.1897 - val_accuracy: 0.9252 Epoch 10/30 24/24 [==============================] - 320s 13s/step - loss: 0.2377 - accuracy: 0.9196 - val_loss: 0.1559 - val_accuracy: 0.9456 Epoch 11/30 24/24 [==============================] - 289s 12s/step - loss: 0.2157 - accuracy: 0.9108 - val_loss: 0.1439 - val_accuracy: 0.9524 Epoch 12/30 24/24 [==============================] - 288s 12s/step - loss: 0.1980 - accuracy: 0.9296 - val_loss: 0.1760 - val_accuracy: 0.9320 Epoch 13/30 24/24 [==============================] - 288s 12s/step - loss: 0.1712 - accuracy: 0.9472 - val_loss: 0.1125 - val_accuracy: 0.9728 Epoch 14/30 24/24 [==============================] - 289s 12s/step - loss: 0.2244 - accuracy: 0.9246 - val_loss: 0.1753 - val_accuracy: 0.9252 Epoch 15/30 24/24 [==============================] - 290s 12s/step - loss: 0.2167 - accuracy: 0.9309 - val_loss: 0.1282 - val_accuracy: 0.9524 Epoch 16/30 24/24 [==============================] - 292s 12s/step - loss: 0.1749 - accuracy: 0.9372 - val_loss: 0.1213 - val_accuracy: 0.9456 Epoch 17/30 24/24 [==============================] - 300s 12s/step - loss: 0.2063 - accuracy: 0.9234 - val_loss: 0.1781 - val_accuracy: 0.9456 Epoch 18/30 24/24 [==============================] - 364s 15s/step - loss: 0.1768 - accuracy: 0.9397 - val_loss: 0.1639 - val_accuracy: 0.9456 Epoch 19/30 24/24 [==============================] - 357s 14s/step - loss: 0.1618 - accuracy: 0.9460 - val_loss: 0.1257 - val_accuracy: 0.9592 Epoch 20/30 24/24 [==============================] - 553s 22s/step - loss: 0.1960 - accuracy: 0.9422 - val_loss: 0.1187 - val_accuracy: 0.9524 Epoch 21/30 24/24 [==============================] - 355s 14s/step - loss: 0.1456 - accuracy: 0.9510 - val_loss: 0.1159 - val_accuracy: 0.9524 Epoch 22/30 24/24 [==============================] - 382s 15s/step - loss: 0.1256 - accuracy: 0.9523 - val_loss: 0.0699 - val_accuracy: 0.9660 Epoch 23/30 24/24 [==============================] - 356s 14s/step - loss: 0.1445 - accuracy: 0.9523 - val_loss: 0.0798 - val_accuracy: 0.9864 Epoch 24/30 24/24 [==============================] - 377s 15s/step - loss: 0.1284 - accuracy: 0.9422 - val_loss: 0.1049 - val_accuracy: 0.9592 Epoch 25/30 24/24 [==============================] - 344s 14s/step - loss: 0.1593 - accuracy: 0.9384 - val_loss: 0.1042 - val_accuracy: 0.9728 Epoch 26/30 24/24 [==============================] - 380s 15s/step - loss: 0.1241 - accuracy: 0.9598 - val_loss: 0.1363 - val_accuracy: 0.9592 Epoch 27/30 24/24 [==============================] - 367s 15s/step - loss: 0.1538 - accuracy: 0.9460 - val_loss: 0.1196 - val_accuracy: 0.9660 Epoch 28/30 24/24 [==============================] - 378s 15s/step - loss: 0.0946 - accuracy: 0.9636 - val_loss: 0.0695 - val_accuracy: 0.9592 Epoch 29/30 24/24 [==============================] - 366s 15s/step - loss: 0.1100 - accuracy: 0.9648 - val_loss: 0.1312 - val_accuracy: 0.9456 Epoch 30/30 24/24 [==============================] - 368s 14s/step - loss: 0.1270 - accuracy: 0.9560 - val_loss: 0.0658 - val_accuracy: 0.9660 ![sci_drop0.4_sgd0.001 -loss](inception-resnet-v2超参数优化记录.assets/i and r loss.png) ![sci_drop0.4_sgd0.001 -acc](inception-resnet-v2超参数优化记录.assets/sci_drop0.4_sgd0.001 -acc.png) 数据集8类（较少），ResNet152V2。adam默认优化器x = base_model.output #添加自己的全链接分类层 x = layers.GlobalAveragePooling2D()(x) x = layers.Dense(1024, activation='relu')(x) predictions = layers.Dense(nb_classes, activation='softmax')(x) #训练模型 model = Model(inputs=base_model.input, outputs=predictions) log： ================开始训练================ Epoch 1/40 17/17 [==============================] - 57s 3s/step - loss: 2.3270 - accuracy: 0.4007 - val_loss: 0.7884 - val_accuracy: 0.7015 Epoch 2/40 17/17 [==============================] - 49s 3s/step - loss: 1.0187 - accuracy: 0.6690 - val_loss: 0.6000 - val_accuracy: 0.8209 Epoch 3/40 17/17 [==============================] - 50s 3s/step - loss: 0.7642 - accuracy: 0.7404 - val_loss: 0.5888 - val_accuracy: 0.7761 Epoch 4/40 17/17 [==============================] - 50s 3s/step - loss: 0.7589 - accuracy: 0.7265 - val_loss: 0.4681 - val_accuracy: 0.8507 Epoch 5/40 17/17 [==============================] - 50s 3s/step - loss: 0.5989 - accuracy: 0.7875 - val_loss: 0.5043 - val_accuracy: 0.8507 Epoch 6/40 17/17 [==============================] - 49s 3s/step - loss: 0.5459 - accuracy: 0.7997 - val_loss: 0.5242 - val_accuracy: 0.8507 Epoch 7/40 17/17 [==============================] - 50s 3s/step - loss: 0.4877 - accuracy: 0.8397 - val_loss: 0.5059 - val_accuracy: 0.8209 Epoch 8/40 17/17 [==============================] - 49s 3s/step - loss: 0.5193 - accuracy: 0.8136 - val_loss: 0.2059 - val_accuracy: 0.9254 Epoch 9/40 17/17 [==============================] - 50s 3s/step - loss: 0.4585 - accuracy: 0.8345 - val_loss: 0.3750 - val_accuracy: 0.8507 Epoch 10/40 17/17 [==============================] - 50s 3s/step - loss: 0.4579 - accuracy: 0.8519 - val_loss: 0.3463 - val_accuracy: 0.8657 Epoch 11/40 17/17 [==============================] - 50s 3s/step - loss: 0.3721 - accuracy: 0.8676 - val_loss: 0.1566 - val_accuracy: 0.9254 Epoch 12/40 17/17 [==============================] - 50s 3s/step - loss: 0.3437 - accuracy: 0.8815 - val_loss: 0.5633 - val_accuracy: 0.8358 Epoch 13/40 17/17 [==============================] - 50s 3s/step - loss: 0.4076 - accuracy: 0.8519 - val_loss: 0.2954 - val_accuracy: 0.9104 Epoch 14/40 17/17 [==============================] - 50s 3s/step - loss: 0.4405 - accuracy: 0.8449 - val_loss: 0.2551 - val_accuracy: 0.8806 Epoch 15/40 17/17 [==============================] - 50s 3s/step - loss: 0.3651 - accuracy: 0.8571 - val_loss: 0.3771 - val_accuracy: 0.8657 Epoch 16/40 17/17 [==============================] - 50s 3s/step - loss: 0.4123 - accuracy: 0.8659 - val_loss: 0.2305 - val_accuracy: 0.8806 Epoch 17/40 17/17 [==============================] - 49s 3s/step - loss: 0.3828 - accuracy: 0.8676 - val_loss: 0.3204 - val_accuracy: 0.9403 Epoch 18/40 17/17 [==============================] - 50s 3s/step - loss: 0.3089 - accuracy: 0.9059 - val_loss: 0.2343 - val_accuracy: 0.8955 Epoch 19/40 17/17 [==============================] - 50s 3s/step - loss: 0.4013 - accuracy: 0.8537 - val_loss: 0.2916 - val_accuracy: 0.8955 Epoch 20/40 17/17 [==============================] - 49s 3s/step - loss: 0.3247 - accuracy: 0.8693 - val_loss: 0.1626 - val_accuracy: 0.9403 Epoch 21/40 17/17 [==============================] - 50s 3s/step - loss: 0.3564 - accuracy: 0.8659 - val_loss: 0.2356 - val_accuracy: 0.9403 Epoch 22/40 17/17 [==============================] - 49s 3s/step - loss: 0.3821 - accuracy: 0.8589 - val_loss: 0.3760 - val_accuracy: 0.8657 Epoch 23/40 17/17 [==============================] - 50s 3s/step - loss: 0.3681 - accuracy: 0.8676 - val_loss: 0.2977 - val_accuracy: 0.8955 Epoch 24/40 17/17 [==============================] - 49s 3s/step - loss: 0.3279 - accuracy: 0.8850 - val_loss: 0.2885 - val_accuracy: 0.8955 Epoch 25/40 17/17 [==============================] - 50s 3s/step - loss: 0.2966 - accuracy: 0.8728 - val_loss: 0.3733 - val_accuracy: 0.8507 Epoch 26/40 17/17 [==============================] - 49s 3s/step - loss: 0.3201 - accuracy: 0.8868 - val_loss: 0.1600 - val_accuracy: 0.9701 Epoch 27/40 17/17 [==============================] - 50s 3s/step - loss: 0.3249 - accuracy: 0.8833 - val_loss: 0.1363 - val_accuracy: 0.9403 Epoch 28/40 17/17 [==============================] - 49s 3s/step - loss: 0.3399 - accuracy: 0.8763 - val_loss: 0.2085 - val_accuracy: 0.9254 Epoch 29/40 17/17 [==============================] - 50s 3s/step - loss: 0.2448 - accuracy: 0.9233 - val_loss: 0.2178 - val_accuracy: 0.9104 Epoch 30/40 17/17 [==============================] - 49s 3s/step - loss: 0.2751 - accuracy: 0.8955 - val_loss: 0.3133 - val_accuracy: 0.8806 Epoch 31/40 17/17 [==============================] - 49s 3s/step - loss: 0.2704 - accuracy: 0.8920 - val_loss: 0.1331 - val_accuracy: 0.9552 Epoch 32/40 17/17 [==============================] - 50s 3s/step - loss: 0.3623 - accuracy: 0.8868 - val_loss: 0.1144 - val_accuracy: 0.9552 Epoch 33/40 17/17 [==============================] - 49s 3s/step - loss: 0.2863 - accuracy: 0.8798 - val_loss: 0.1851 - val_accuracy: 0.9403 Epoch 34/40 17/17 [==============================] - 50s 3s/step - loss: 0.2935 - accuracy: 0.9059 - val_loss: 0.1641 - val_accuracy: 0.9552 Epoch 35/40 17/17 [==============================] - 49s 3s/step - loss: 0.2440 - accuracy: 0.9146 - val_loss: 0.2485 - val_accuracy: 0.9254 Epoch 36/40 17/17 [==============================] - 50s 3s/step - loss: 0.2578 - accuracy: 0.9111 - val_loss: 0.1363 - val_accuracy: 0.9552 Epoch 37/40 17/17 [==============================] - 50s 3s/step - loss: 0.2798 - accuracy: 0.9042 - val_loss: 0.1749 - val_accuracy: 0.9403 Epoch 38/40 17/17 [==============================] - 50s 3s/step - loss: 0.2619 - accuracy: 0.9077 - val_loss: 0.2854 - val_accuracy: 0.8955 Epoch 39/40 17/17 [==============================] - 49s 3s/step - loss: 0.1995 - accuracy: 0.9303 - val_loss: 0.1245 - val_accuracy: 0.9851 Epoch 40/40 17/17 [==============================] - 50s 3s/step - loss: 0.2499 - accuracy: 0.9111 - val_loss: 0.2573 - val_accuracy: 0.9254 ================保存模型================ 计算中断未获取到acc-loss图。","categories":[{"name":"图像分类","slug":"图像分类","permalink":"https://jlexzhong.github.io/blog/categories/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://jlexzhong.github.io/blog/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/tags/tensorflow/"},{"name":"keras","slug":"keras","permalink":"https://jlexzhong.github.io/blog/tags/keras/"},{"name":"图像分类","slug":"图像分类","permalink":"https://jlexzhong.github.io/blog/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"}]},{"title":"pyqt小记 | 添加右键菜单，添加图标和点击事件","slug":"pyqt-context-add-icon-click","date":"2021-08-17T15:12:35.000Z","updated":"2021-09-14T02:20:58.932Z","comments":true,"path":"2021/08/17/pyqt-context-add-icon-click/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/17/pyqt-context-add-icon-click/","excerpt":"","text":"pyqt小记 | 添加右键菜单，添加图标和点击事件def contextMenuEvent(self, pos): \"\"\" 右键菜单 :param pos: :return: \"\"\" self.contextMenu = QMenu() self.action_pgPlot = self.contextMenu.addAction( QIcon(\"./icons/logo.ico\"), u'| 使用PyqtGraph绘制散点图') self.action_plotCircle = self.contextMenu.addAction( QIcon(\"./icons/plot.ico\"), u'| 使用matplotlib绘制二维圆图') self.action_plotPoint = self.contextMenu.addAction( QIcon(\"./icons/plotPoint.png\"), u'| 使用matplotlib绘制散点图') self.action_clear_dataView = self.contextMenu.addAction( QIcon(\"./icons/clear.ico\"), u'| 清除数据与图像') self.contextMenu.popup(QCursor.pos()) # 菜单显示的位置 self.action_plotCircle.triggered.connect(self.plotAllSlot_circle) self.action_plotPoint.triggered.connect(self.plotAllSlot_point) self.action_pgPlot.triggered.connect(self.pg_plot) font = QtGui.QFont() font.setFamily(\"黑体\") font.setPointSize(10) font.setBold(True) self.action_pgPlot.setFont(font) self.action_clear_dataView.triggered.connect(self.clear_dataView) self.contextMenu.show() 类继承于QTableView 效果： ![](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/pyqt小记 添加右键菜单，添加图标和点击事件.assets/右键菜单 2021-08-19 133503.png)","categories":[],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/tags/PyQt/"},{"name":"GUI","slug":"GUI","permalink":"https://jlexzhong.github.io/blog/tags/GUI/"}]},{"title":"tensorflow2 模型的保存和载入 h5和ckpt的用法 断点续训","slug":"tensorflow2-load-save","date":"2021-08-15T04:00:09.000Z","updated":"2021-09-14T02:22:15.688Z","comments":true,"path":"2021/08/15/tensorflow2-load-save/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/15/tensorflow2-load-save/","excerpt":"","text":"tensorflow2 模型的保存和载入 h5和ckpt的用法 | 小记断点续训/检查点# 断点续训 checkpoint_path = 'ckpt/transfer_{epoch:02d}-{val_acc:.2f}.ckpt' # 格式化字符，防止文件名冲突 checkpoint_callback = tf.keras.callbacks.ModelCheckpoint(checkpoint_path, # 保存路径 monitor='val_acc', # 监测指标，这里是测试集的acc save_weights_only=False, #是否只保存权重 mode='auto', period=1 # 每period个周期保存一次 ) # 需要在fit/fit_generator()中添加该回调函数 history_ft = model.fit_generator( train_generator, steps_per_epoch=steps_per_epoch, epochs=epochs, validation_data=validation_generator, validation_steps=validation_steps, callbacks = [checkpoint_callback]) 保存全部模型（ckpt）：![image-20210814230542472](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/tensorflow2 模型的保存和载入用法.assets/all_ckpt.png) 读取方法： model = tf.keras.models.load_model('./ckpt/transfer_03-0.98.ckpt') 保存全部模型（h5）:![image-20210814233340073](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/tensorflow2 模型的保存和载入用法.assets/all_h5.png) 读取方法: model = load_model('./ckpt/transfer_06-0.94.h5') 仅保存权重（ckpt）：读取方法： checkpoint_path = 'ckpt/transfer_{epoch:02d}-{val_acc:.2f}.ckpt' checkpoint_dir = os.path.dirname(checkpoint_path) latest_model = tf.train.latest_checkpoint(checkpoint_dir) # 找到最新保存的断点 model.load_weights(latest_model) # 读取权重，model的结构必须与训练的网络结构一致 仅保存权重（h5）![](https://cdn.jsdelivr.net/gh/JlexZhong/J.CS-note@main/tensorflow2 模型的保存和载入用法.assets/only_h5.png) model.load_weights('./ckpt/transfer_18-0.97.h5') tf.train.latest_checkpoint() 方法用于找到目录下最新的检查点 并且似乎只对ckpt有作用 model.save()保存模型path_save_model = 'model/my_saved_InceptionV3_model.h5' model.save(path_save_model, overwrite=True)","categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/categories/tensorflow/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://jlexzhong.github.io/blog/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/tags/tensorflow/"}]},{"title":"我的第一篇博客","slug":"first_blog","date":"2021-08-13T14:42:55.000Z","updated":"2021-09-14T02:18:46.421Z","comments":true,"path":"2021/08/13/first_blog/","link":"","permalink":"https://jlexzhong.github.io/blog/2021/08/13/first_blog/","excerpt":"","text":"大家好，这是我的第一篇博客，见证了自建个人博客的成功。 接下来，我将在这里发布我的学习记录和问题，以及一些项目，敬请期待！ 本人非科班选手，如有不足还望各位指正哦！","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://jlexzhong.github.io/blog/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/categories/tensorflow/"},{"name":"Python","slug":"Python","permalink":"https://jlexzhong.github.io/blog/categories/Python/"},{"name":"Mask R-CNN","slug":"Mask-R-CNN","permalink":"https://jlexzhong.github.io/blog/categories/Mask-R-CNN/"},{"name":"图像分类","slug":"图像分类","permalink":"https://jlexzhong.github.io/blog/categories/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"},{"name":"python","slug":"python","permalink":"https://jlexzhong.github.io/blog/categories/python/"},{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/categories/PyQt/"},{"name":"hexo","slug":"hexo","permalink":"https://jlexzhong.github.io/blog/categories/hexo/"},{"name":"HTML","slug":"HTML","permalink":"https://jlexzhong.github.io/blog/categories/HTML/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://jlexzhong.github.io/blog/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://jlexzhong.github.io/blog/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://jlexzhong.github.io/blog/tags/tensorflow/"},{"name":"keras","slug":"keras","permalink":"https://jlexzhong.github.io/blog/tags/keras/"},{"name":"BUG","slug":"BUG","permalink":"https://jlexzhong.github.io/blog/tags/BUG/"},{"name":"Python","slug":"Python","permalink":"https://jlexzhong.github.io/blog/tags/Python/"},{"name":"Mask R-CNN","slug":"Mask-R-CNN","permalink":"https://jlexzhong.github.io/blog/tags/Mask-R-CNN/"},{"name":"实例分割","slug":"实例分割","permalink":"https://jlexzhong.github.io/blog/tags/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"},{"name":"tensorflow.js","slug":"tensorflow-js","permalink":"https://jlexzhong.github.io/blog/tags/tensorflow-js/"},{"name":"图像分类","slug":"图像分类","permalink":"https://jlexzhong.github.io/blog/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"},{"name":"python","slug":"python","permalink":"https://jlexzhong.github.io/blog/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://jlexzhong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"PyQt","slug":"PyQt","permalink":"https://jlexzhong.github.io/blog/tags/PyQt/"},{"name":"GUI","slug":"GUI","permalink":"https://jlexzhong.github.io/blog/tags/GUI/"},{"name":"pyqtgraph","slug":"pyqtgraph","permalink":"https://jlexzhong.github.io/blog/tags/pyqtgraph/"},{"name":"hexo","slug":"hexo","permalink":"https://jlexzhong.github.io/blog/tags/hexo/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://jlexzhong.github.io/blog/tags/matplotlib/"},{"name":"HTML","slug":"HTML","permalink":"https://jlexzhong.github.io/blog/tags/HTML/"},{"name":"搭建博客","slug":"搭建博客","permalink":"https://jlexzhong.github.io/blog/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"github","slug":"github","permalink":"https://jlexzhong.github.io/blog/tags/github/"},{"name":"matery","slug":"matery","permalink":"https://jlexzhong.github.io/blog/tags/matery/"},{"name":"生活","slug":"生活","permalink":"https://jlexzhong.github.io/blog/tags/%E7%94%9F%E6%B4%BB/"}]}